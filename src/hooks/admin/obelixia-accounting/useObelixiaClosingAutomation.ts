/**
 * ObelixIA Closing Automation Hook
 * Fase 15 - Enterprise SaaS 2025-2026
 * 
 * Automatización del cierre contable mensual/anual
 * con validaciones automáticas y checklist inteligente
 */

import { useState, useCallback, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

// === INTERFACES ===
export interface ClosingPeriod {
  id: string;
  type: 'monthly' | 'quarterly' | 'annual';
  year: number;
  month?: number;
  quarter?: number;
  status: 'open' | 'in_progress' | 'pending_review' | 'closed' | 'locked';
  startDate: string;
  endDate: string;
  closingDeadline: string;
  closedAt?: string;
  closedBy?: string;
  progress: number;
  validationsPassed: number;
  validationsTotal: number;
  createdAt: string;
  updatedAt: string;
}

export interface ClosingTask {
  id: string;
  periodId: string;
  category: 'reconciliation' | 'adjustments' | 'validation' | 'reporting' | 'approval';
  name: string;
  description: string;
  order: number;
  status: 'pending' | 'in_progress' | 'completed' | 'blocked' | 'skipped';
  isRequired: boolean;
  isAutomated: boolean;
  automationResult?: {
    success: boolean;
    message: string;
    details?: Record<string, unknown>;
  };
  assignedTo?: string;
  completedAt?: string;
  completedBy?: string;
  notes?: string;
  dependencies: string[];
  estimatedMinutes: number;
  actualMinutes?: number;
}

export interface ClosingValidation {
  id: string;
  periodId: string;
  type: 'balance' | 'reconciliation' | 'compliance' | 'consistency' | 'completeness';
  name: string;
  description: string;
  status: 'pending' | 'passed' | 'failed' | 'warning' | 'skipped';
  severity: 'critical' | 'high' | 'medium' | 'low';
  result?: {
    expected: string | number;
    actual: string | number;
    difference?: number;
    percentageDiff?: number;
  };
  recommendation?: string;
  executedAt?: string;
  autoFixable: boolean;
}

export interface ClosingAdjustment {
  id: string;
  periodId: string;
  type: 'accrual' | 'depreciation' | 'provision' | 'reclassification' | 'correction' | 'reversal';
  description: string;
  amount: number;
  debitAccount: { id: string; code: string; name: string };
  creditAccount: { id: string; code: string; name: string };
  status: 'proposed' | 'approved' | 'posted' | 'rejected';
  isAutoGenerated: boolean;
  generatedBy?: string;
  approvedBy?: string;
  postedAt?: string;
  journalEntryId?: string;
  justification: string;
  createdAt: string;
}

export interface ClosingChecklist {
  periodId: string;
  periodType: 'monthly' | 'quarterly' | 'annual';
  categories: Array<{
    id: string;
    name: string;
    order: number;
    tasks: ClosingTask[];
    completedCount: number;
    totalCount: number;
  }>;
  overallProgress: number;
  estimatedCompletion: string;
  blockers: Array<{
    taskId: string;
    taskName: string;
    reason: string;
    resolution?: string;
  }>;
}

export interface ClosingStats {
  periodsClosedThisYear: number;
  averageClosingDays: number;
  onTimeClosingRate: number;
  automationRate: number;
  lastClosingDuration: number;
  pendingAdjustments: number;
  failedValidations: number;
}

// === HOOK ===
export function useObelixiaClosingAutomation() {
  const [isLoading, setIsLoading] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [periods, setPeriods] = useState<ClosingPeriod[]>([]);
  const [activePeriod, setActivePeriod] = useState<ClosingPeriod | null>(null);
  const [checklist, setChecklist] = useState<ClosingChecklist | null>(null);
  const [validations, setValidations] = useState<ClosingValidation[]>([]);
  const [adjustments, setAdjustments] = useState<ClosingAdjustment[]>([]);
  const [stats, setStats] = useState<ClosingStats | null>(null);
  const [error, setError] = useState<string | null>(null);

  // === OBTENER PERÍODOS ===
  const fetchPeriods = useCallback(async (year?: number) => {
    setIsLoading(true);
    try {
      // Datos de demostración
      const demoPeriods: ClosingPeriod[] = [
        {
          id: 'period-dec-2024',
          type: 'monthly',
          year: 2024,
          month: 12,
          status: 'in_progress',
          startDate: '2024-12-01',
          endDate: '2024-12-31',
          closingDeadline: '2025-01-15',
          progress: 65,
          validationsPassed: 8,
          validationsTotal: 12,
          createdAt: '2024-12-01T00:00:00Z',
          updatedAt: new Date().toISOString()
        },
        {
          id: 'period-nov-2024',
          type: 'monthly',
          year: 2024,
          month: 11,
          status: 'closed',
          startDate: '2024-11-01',
          endDate: '2024-11-30',
          closingDeadline: '2024-12-15',
          closedAt: '2024-12-12T14:30:00Z',
          progress: 100,
          validationsPassed: 12,
          validationsTotal: 12,
          createdAt: '2024-11-01T00:00:00Z',
          updatedAt: '2024-12-12T14:30:00Z'
        },
        {
          id: 'period-q4-2024',
          type: 'quarterly',
          year: 2024,
          quarter: 4,
          status: 'pending_review',
          startDate: '2024-10-01',
          endDate: '2024-12-31',
          closingDeadline: '2025-01-31',
          progress: 85,
          validationsPassed: 18,
          validationsTotal: 22,
          createdAt: '2024-10-01T00:00:00Z',
          updatedAt: new Date().toISOString()
        },
        {
          id: 'period-2024',
          type: 'annual',
          year: 2024,
          status: 'open',
          startDate: '2024-01-01',
          endDate: '2024-12-31',
          closingDeadline: '2025-03-31',
          progress: 45,
          validationsPassed: 25,
          validationsTotal: 45,
          createdAt: '2024-01-01T00:00:00Z',
          updatedAt: new Date().toISOString()
        }
      ];

      setPeriods(demoPeriods);
      return demoPeriods;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Error desconocido';
      setError(message);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, []);

  // === OBTENER CHECKLIST DE CIERRE ===
  const fetchChecklist = useCallback(async (periodId: string) => {
    setIsLoading(true);
    try {
      const demoChecklist: ClosingChecklist = {
        periodId,
        periodType: 'monthly',
        categories: [
          {
            id: 'cat-reconciliation',
            name: 'Conciliaciones',
            order: 1,
            tasks: [
              {
                id: 'task-bank-rec',
                periodId,
                category: 'reconciliation',
                name: 'Conciliación bancaria',
                description: 'Conciliar todos los extractos bancarios del período',
                order: 1,
                status: 'completed',
                isRequired: true,
                isAutomated: true,
                automationResult: { success: true, message: 'Conciliación automática completada' },
                completedAt: new Date(Date.now() - 86400000).toISOString(),
                dependencies: [],
                estimatedMinutes: 30,
                actualMinutes: 5
              },
              {
                id: 'task-ar-rec',
                periodId,
                category: 'reconciliation',
                name: 'Conciliación cuentas por cobrar',
                description: 'Verificar saldos de clientes vs mayor contable',
                order: 2,
                status: 'completed',
                isRequired: true,
                isAutomated: true,
                completedAt: new Date(Date.now() - 82800000).toISOString(),
                dependencies: [],
                estimatedMinutes: 45,
                actualMinutes: 8
              },
              {
                id: 'task-ap-rec',
                periodId,
                category: 'reconciliation',
                name: 'Conciliación cuentas por pagar',
                description: 'Verificar saldos de proveedores vs mayor contable',
                order: 3,
                status: 'in_progress',
                isRequired: true,
                isAutomated: true,
                dependencies: [],
                estimatedMinutes: 45
              }
            ],
            completedCount: 2,
            totalCount: 3
          },
          {
            id: 'cat-adjustments',
            name: 'Ajustes de Cierre',
            order: 2,
            tasks: [
              {
                id: 'task-depreciation',
                periodId,
                category: 'adjustments',
                name: 'Registro de depreciación',
                description: 'Calcular y registrar depreciación mensual de activos',
                order: 1,
                status: 'completed',
                isRequired: true,
                isAutomated: true,
                automationResult: { success: true, message: 'Depreciación calculada: €2,450.00' },
                completedAt: new Date(Date.now() - 79200000).toISOString(),
                dependencies: [],
                estimatedMinutes: 15,
                actualMinutes: 2
              },
              {
                id: 'task-accruals',
                periodId,
                category: 'adjustments',
                name: 'Devengos y provisiones',
                description: 'Registrar gastos devengados y provisiones del período',
                order: 2,
                status: 'pending',
                isRequired: true,
                isAutomated: false,
                dependencies: ['task-depreciation'],
                estimatedMinutes: 60
              },
              {
                id: 'task-prepaid',
                periodId,
                category: 'adjustments',
                name: 'Amortización de prepagos',
                description: 'Amortizar gastos prepagados del período',
                order: 3,
                status: 'pending',
                isRequired: true,
                isAutomated: true,
                dependencies: [],
                estimatedMinutes: 15
              }
            ],
            completedCount: 1,
            totalCount: 3
          },
          {
            id: 'cat-validation',
            name: 'Validaciones',
            order: 3,
            tasks: [
              {
                id: 'task-trial-balance',
                periodId,
                category: 'validation',
                name: 'Verificar balance de comprobación',
                description: 'Confirmar que débitos = créditos',
                order: 1,
                status: 'completed',
                isRequired: true,
                isAutomated: true,
                automationResult: { success: true, message: 'Balance cuadrado correctamente' },
                completedAt: new Date(Date.now() - 75600000).toISOString(),
                dependencies: ['task-depreciation', 'task-ar-rec', 'task-ap-rec'],
                estimatedMinutes: 5,
                actualMinutes: 1
              },
              {
                id: 'task-analytics-check',
                periodId,
                category: 'validation',
                name: 'Revisión analítica',
                description: 'Comparar variaciones significativas vs período anterior',
                order: 2,
                status: 'pending',
                isRequired: true,
                isAutomated: true,
                dependencies: ['task-trial-balance'],
                estimatedMinutes: 20
              }
            ],
            completedCount: 1,
            totalCount: 2
          },
          {
            id: 'cat-reporting',
            name: 'Reportes',
            order: 4,
            tasks: [
              {
                id: 'task-gen-reports',
                periodId,
                category: 'reporting',
                name: 'Generar estados financieros',
                description: 'Generar Balance, P&L y Estado de Flujos',
                order: 1,
                status: 'pending',
                isRequired: true,
                isAutomated: true,
                dependencies: ['task-analytics-check'],
                estimatedMinutes: 10
              },
              {
                id: 'task-management-report',
                periodId,
                category: 'reporting',
                name: 'Informe de gestión',
                description: 'Preparar informe ejecutivo del período',
                order: 2,
                status: 'pending',
                isRequired: false,
                isAutomated: false,
                dependencies: ['task-gen-reports'],
                estimatedMinutes: 120
              }
            ],
            completedCount: 0,
            totalCount: 2
          },
          {
            id: 'cat-approval',
            name: 'Aprobación',
            order: 5,
            tasks: [
              {
                id: 'task-review',
                periodId,
                category: 'approval',
                name: 'Revisión del controller',
                description: 'Revisión y aprobación por el controller financiero',
                order: 1,
                status: 'pending',
                isRequired: true,
                isAutomated: false,
                dependencies: ['task-gen-reports'],
                estimatedMinutes: 60
              },
              {
                id: 'task-final-close',
                periodId,
                category: 'approval',
                name: 'Cierre final del período',
                description: 'Bloquear período para modificaciones',
                order: 2,
                status: 'pending',
                isRequired: true,
                isAutomated: false,
                dependencies: ['task-review'],
                estimatedMinutes: 5
              }
            ],
            completedCount: 0,
            totalCount: 2
          }
        ],
        overallProgress: 65,
        estimatedCompletion: new Date(Date.now() + 259200000).toISOString(),
        blockers: []
      };

      setChecklist(demoChecklist);
      return demoChecklist;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Error desconocido';
      setError(message);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  // === EJECUTAR TAREA AUTOMÁTICA ===
  const executeAutomatedTask = useCallback(async (taskId: string) => {
    setIsProcessing(true);
    try {
      // Simular ejecución
      await new Promise(resolve => setTimeout(resolve, 2000));

      if (checklist) {
        setChecklist(prev => {
          if (!prev) return prev;
          return {
            ...prev,
            categories: prev.categories.map(cat => ({
              ...cat,
              tasks: cat.tasks.map(task =>
                task.id === taskId
                  ? {
                      ...task,
                      status: 'completed' as const,
                      completedAt: new Date().toISOString(),
                      automationResult: { success: true, message: 'Tarea completada automáticamente' }
                    }
                  : task
              ),
              completedCount: cat.tasks.filter(t => 
                t.id === taskId || t.status === 'completed'
              ).length
            }))
          };
        });
      }

      toast.success('Tarea ejecutada correctamente');
      return true;
    } catch (err) {
      toast.error('Error al ejecutar tarea');
      return false;
    } finally {
      setIsProcessing(false);
    }
  }, [checklist]);

  // === COMPLETAR TAREA MANUAL ===
  const completeTask = useCallback(async (taskId: string, notes?: string) => {
    try {
      if (checklist) {
        setChecklist(prev => {
          if (!prev) return prev;
          return {
            ...prev,
            categories: prev.categories.map(cat => ({
              ...cat,
              tasks: cat.tasks.map(task =>
                task.id === taskId
                  ? {
                      ...task,
                      status: 'completed' as const,
                      completedAt: new Date().toISOString(),
                      notes
                    }
                  : task
              ),
              completedCount: cat.tasks.filter(t => 
                t.id === taskId || t.status === 'completed'
              ).length
            }))
          };
        });
      }

      toast.success('Tarea marcada como completada');
      return true;
    } catch (err) {
      toast.error('Error al completar tarea');
      return false;
    }
  }, [checklist]);

  // === EJECUTAR VALIDACIONES ===
  const runValidations = useCallback(async (periodId: string) => {
    setIsProcessing(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 3000));

      const demoValidations: ClosingValidation[] = [
        {
          id: 'val-balance',
          periodId,
          type: 'balance',
          name: 'Balance de comprobación',
          description: 'Verificar que total débitos = total créditos',
          status: 'passed',
          severity: 'critical',
          result: { expected: 0, actual: 0 },
          executedAt: new Date().toISOString(),
          autoFixable: false
        },
        {
          id: 'val-bank-rec',
          periodId,
          type: 'reconciliation',
          name: 'Conciliación bancaria',
          description: 'Diferencia entre saldo contable y extracto bancario',
          status: 'passed',
          severity: 'high',
          result: { expected: 0, actual: 0 },
          executedAt: new Date().toISOString(),
          autoFixable: false
        },
        {
          id: 'val-cutoff',
          periodId,
          type: 'completeness',
          name: 'Corte de operaciones',
          description: 'Verificar que todas las transacciones están en el período correcto',
          status: 'warning',
          severity: 'medium',
          result: { expected: '2024-12-31', actual: '2 transacciones pendientes' },
          recommendation: 'Revisar 2 facturas de venta con fecha 31/12 no registradas',
          executedAt: new Date().toISOString(),
          autoFixable: false
        },
        {
          id: 'val-depreciation',
          periodId,
          type: 'consistency',
          name: 'Consistencia de depreciación',
          description: 'Verificar cálculo de depreciación mensual',
          status: 'passed',
          severity: 'medium',
          result: { expected: 2450, actual: 2450 },
          executedAt: new Date().toISOString(),
          autoFixable: true
        },
        {
          id: 'val-intercompany',
          periodId,
          type: 'reconciliation',
          name: 'Saldos intercompañía',
          description: 'Verificar que saldos IC cuadren entre entidades',
          status: 'failed',
          severity: 'high',
          result: { expected: 0, actual: 1250.50, difference: 1250.50 },
          recommendation: 'Diferencia de €1,250.50 en cuenta con filial UK. Revisar factura #4521.',
          executedAt: new Date().toISOString(),
          autoFixable: false
        }
      ];

      setValidations(demoValidations);
      toast.success(`Validaciones completadas: ${demoValidations.filter(v => v.status === 'passed').length}/${demoValidations.length} pasadas`);
      return demoValidations;
    } catch (err) {
      toast.error('Error al ejecutar validaciones');
      return [];
    } finally {
      setIsProcessing(false);
    }
  }, []);

  // === GENERAR AJUSTES AUTOMÁTICOS ===
  const generateAdjustments = useCallback(async (periodId: string) => {
    setIsProcessing(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 2000));

      const demoAdjustments: ClosingAdjustment[] = [
        {
          id: 'adj-depreciation',
          periodId,
          type: 'depreciation',
          description: 'Depreciación mensual de activos fijos - Diciembre 2024',
          amount: 2450.00,
          debitAccount: { id: 'acc-dep-exp', code: '681', name: 'Gasto de depreciación' },
          creditAccount: { id: 'acc-accum-dep', code: '281', name: 'Depreciación acumulada' },
          status: 'proposed',
          isAutoGenerated: true,
          generatedBy: 'IA Guardian',
          justification: 'Cálculo automático basado en tabla de activos fijos',
          createdAt: new Date().toISOString()
        },
        {
          id: 'adj-accrual-interest',
          periodId,
          type: 'accrual',
          description: 'Devengo de intereses de préstamo bancario',
          amount: 875.00,
          debitAccount: { id: 'acc-int-exp', code: '662', name: 'Gastos por intereses' },
          creditAccount: { id: 'acc-int-payable', code: '527', name: 'Intereses a pagar' },
          status: 'proposed',
          isAutoGenerated: true,
          generatedBy: 'IA Guardian',
          justification: 'Intereses devengados del préstamo #1234 (tasa 5% anual)',
          createdAt: new Date().toISOString()
        },
        {
          id: 'adj-prepaid',
          periodId,
          type: 'accrual',
          description: 'Amortización seguro anual - parte proporcional diciembre',
          amount: 450.00,
          debitAccount: { id: 'acc-insurance', code: '625', name: 'Primas de seguros' },
          creditAccount: { id: 'acc-prepaid', code: '480', name: 'Gastos anticipados' },
          status: 'proposed',
          isAutoGenerated: true,
          generatedBy: 'IA Guardian',
          justification: 'Amortización 1/12 de póliza anual (€5,400)',
          createdAt: new Date().toISOString()
        }
      ];

      setAdjustments(demoAdjustments);
      toast.success(`${demoAdjustments.length} ajustes propuestos generados`);
      return demoAdjustments;
    } catch (err) {
      toast.error('Error al generar ajustes');
      return [];
    } finally {
      setIsProcessing(false);
    }
  }, []);

  // === APROBAR AJUSTE ===
  const approveAdjustment = useCallback(async (adjustmentId: string) => {
    try {
      setAdjustments(prev => prev.map(adj =>
        adj.id === adjustmentId
          ? { ...adj, status: 'approved' as const, approvedBy: 'current-user' }
          : adj
      ));
      toast.success('Ajuste aprobado');
      return true;
    } catch (err) {
      toast.error('Error al aprobar ajuste');
      return false;
    }
  }, []);

  // === CONTABILIZAR AJUSTES APROBADOS ===
  const postApprovedAdjustments = useCallback(async (periodId: string) => {
    setIsProcessing(true);
    try {
      const approvedAdjs = adjustments.filter(a => a.status === 'approved');
      if (approvedAdjs.length === 0) {
        toast.warning('No hay ajustes aprobados para contabilizar');
        return false;
      }

      await new Promise(resolve => setTimeout(resolve, 1500));

      setAdjustments(prev => prev.map(adj =>
        adj.status === 'approved'
          ? { ...adj, status: 'posted' as const, postedAt: new Date().toISOString() }
          : adj
      ));

      toast.success(`${approvedAdjs.length} ajustes contabilizados`);
      return true;
    } catch (err) {
      toast.error('Error al contabilizar ajustes');
      return false;
    } finally {
      setIsProcessing(false);
    }
  }, [adjustments]);

  // === CERRAR PERÍODO ===
  const closePeriod = useCallback(async (periodId: string) => {
    setIsProcessing(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 2000));

      setPeriods(prev => prev.map(p =>
        p.id === periodId
          ? {
              ...p,
              status: 'closed' as const,
              closedAt: new Date().toISOString(),
              progress: 100
            }
          : p
      ));

      toast.success('Período cerrado correctamente');
      return true;
    } catch (err) {
      toast.error('Error al cerrar período');
      return false;
    } finally {
      setIsProcessing(false);
    }
  }, []);

  // === OBTENER ESTADÍSTICAS ===
  const fetchStats = useCallback(async () => {
    const demoStats: ClosingStats = {
      periodsClosedThisYear: 11,
      averageClosingDays: 4.2,
      onTimeClosingRate: 91,
      automationRate: 78,
      lastClosingDuration: 3,
      pendingAdjustments: 3,
      failedValidations: 1
    };

    setStats(demoStats);
    return demoStats;
  }, []);

  // === INICIALIZAR ===
  useEffect(() => {
    fetchPeriods();
    fetchStats();
  }, [fetchPeriods, fetchStats]);

  return {
    // Estado
    isLoading,
    isProcessing,
    periods,
    activePeriod,
    checklist,
    validations,
    adjustments,
    stats,
    error,

    // Acciones de períodos
    fetchPeriods,
    setActivePeriod,
    closePeriod,

    // Acciones de checklist
    fetchChecklist,
    executeAutomatedTask,
    completeTask,

    // Acciones de validaciones
    runValidations,

    // Acciones de ajustes
    generateAdjustments,
    approveAdjustment,
    postApprovedAdjustments,

    // Estadísticas
    fetchStats
  };
}

export default useObelixiaClosingAutomation;
